---
week: 1
pagetitle: Introduction to Python
---

- [Overview](#overview-and-objectives)
- [Background](#background)
- [Further Reading](#further-reading)
- [Notebooks](#notebooks)

## Basics

In this course we will be using the Python programming language.
The material this week will help familiarize you with how to perform basic tasks in Python, as well as provide some context for why Python is a good programming language to learn.

## Motivation: Why learn Python?

There are lots of programming languages, and lots of different things to invest your time in learning other than programming. So why is learning Python a worthwhile investment of your time?

- *With Python, there are no limits to the complexity of programs you can build.* It's no question that computers are becoming increasingly important in all walks of life. In addition to science applications, Python is used in building all sorts of software and apps, such as websites, games, graphical user interfaces (GUIs), business software, operating systems, etc. Examples of Python-built applications include Google's search engine, Dropbox, and YouTube. There is nearly no limit to what you can design and build using Python, and it could become an invaluable tool in your future career. Even if you need to write components of your programs in a different language (such as a C library for a doing a certain type of computation efficiently), your Python program can easily communicate with it.

- *Python is a high-level language, which frees you from the more tedious and formal aspects of programming.* In a lower-level programming language such as C, the programmer needs to interact more directly with the memory and operating system. Variables need to be declared and memory needs to be allocated before the variables can be used. In short, you need to invest a lot of time into the technical aspects of computer science before starting to do anything. With Python, programming is more intuitive because the technical "low-level" parts are automatically taken care of behind the scenes, and you are free to think about the "high-level" or conceptual aspects of your program.

- *Python is an interpreted language, and as such, there is no need to compile Python code to run it.* When writing codes in C, Fortran or Java, a program called a compiler is needed to convert the source code into a runnable program.  The program itself is comprised of instructions to the CPU and is generally not human-readable.  On the other hand, for interpreted languages such as Python, the lines of code are read by a program called an interpreter which executes the code line by line (the Python executable and the Python interpreter are in fact the same thing).  This model makes it easier for pieces of code to be shared and used rapidly, compared to compiled programs.  All these small conveniences add up to rapid development of programs and applications.

- *Python has an extensive free software ecosystem.* The Python open-source community has created thousands of free available *packages* (called libraries in other languages) that can be easily downloaded over the Internet and used in your own program. Many of these packages are available free of charge, including all the ones we are using in this course. Some packages provide new variable types that make it easy to deal with complex problems; for example, the `array` class in NumPy allows one to work with multidimensional arrays and matrices, similar to Matlab, and the `dataframe` class in Pandas allows one to read, merge, and analyze data in tabular form, similar to Excel but with the automation capabilities of a programming language. Other packages provide new ways for you to use Python, such as the `jupyter` notebook that we use for all of our course exercises. There are also chemistry-specific Python packages that allow you to manipulate molecular structures and run simulations.


<details closed>

<summary> <i>Why Python - a personal perspective </i></summary>

<br>

Here's a bit of personal information about me, in case you're interested in knowing how I got into programming and why it's an interesting topic for me.<br><br>

I first started using Python in grad school, where I was first introduced to theoretical and computational chemistry.
During my undergrad research in a bioengineering lab, I had written some image recognition scripts using Matlab that determined cell counts and cell shapes from videos of blood samples taken under a microscope. (Prior to my undergrad Matlab experience, I had taken a C++ course in high school but I wasn't a very good student.)<br><br>

I was surprised to find out how easily my Matlab experience transferred to Python. In particular, it was easy to use NumPy's arrays as a substitute for Matlab's matrices. I also found that it was easy to use Python to parse and modify files, as well as execute other programs automatically. These automation tools allowed me to efficiently carry out research tasks that would not have been possible otherwise, such as extracting thousands of structures from a simulation trajectory, running quantum chemistry calculations on each structure, and processing the results. I also learned numerical optimization in grad school and used Python to write a software package to improve the accuracy of force field models for proteins and other biomolecules.<br><br>

In my postdoc, a large portion of my research involved Python programming and I published my force field optimization software "ForceBalance" and made it available to the scientific community. Over the years, ForceBalance and the force field models that were built with it gained traction due to the models' high accuracy and ease of reproducibility. More recently I also wrote a software package for geometry optimization that incorporates a lot of what I learned when writing ForceBalance. The new geometry optimization software "geomeTRIC" allowed me to implement and test a new coordinate system for optimizing the structures of molecules that enables calculations to converge more quickly and more reliably than before. <br><br>

Overall, I think Python has become one of my most important research tools mainly for these reasons:<br><br>
(1) Python makes it easy to implement mathematical formulas and apply them in practice, providing a bridge from "pen and paper" research to large scale computations.<br>
(2) Python makes it easy to automate other programs, and enables the development of workflows and procedures that would be too complex if done manually.<br>
(3) Python is widely used by the research community, making it easy for others to use and benefit from my research codes, and increasing my research impact in the process. <br>
</details><br>

## Orienting yourself: Python interpreter, packages, environments

*Note:* This section will assume that you've already installed Miniconda and the environment following the [Installation instructions]({{ site.baseurl }}{% link installation.md %}).
You may already have Python on your computer, but you will still need to follow the instructions to get your environment set up with all of the needed packages.

The basic Python interpreter is a program you can run by entering `python` in your Mac OS or Linux (or WSL) terminal.
The interpreter will give you an interactive `>>>` prompt, which understands Python commands such as `print("Hello world!")`

```bash
(base) leeping@desktop:~$ python
Python 3.9.13 | packaged by conda-forge | (main, May 27 2022, 16:56:21)
[GCC 10.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> print("Hello world!")
Hello world!
```

It is easy to get confused and type Python codes into the terminal without running the interpreter. 
Because the language of the terminal is bash (or another shell such as dash or zsh), not python, you will get an error message if you do this.
```bash
(base) leeping@desktop:~$ print("Hello world!")
-bash: syntax error near unexpected token `"Hello world!"'
```

The `(base)` part of your prompt is added by the `conda` package manager (which comes with Miniconda), and it shows that you are in the base environment, which is the default.
By setting the environment you are specifying a particular copy of the Python interpreter and a self-contained set of packages.
The ability to have separate environments is useful because there are multiple versions of Python and not all packages are mutually compatible.
As you learned in the Installation section, `conda` can create environments with different Python versions, and add packages into them while checking compatibility, but it doesn't always work as smoothly as advertised.. ðŸ˜¤

Now activate the `che155` environment, use `cd` to go into your designated CHE155 folder (optional, but recommended), and run `jupyter lab` as in the Installation instructions (bottom portion).
Click the link to open the Jupyter Lab environment. 
From the Launcher you can open a new notebook with a single blank cell.


<details closed>

<summary> <i> When changing to a directory with <code>cd</code>, are you typing in the Python language, the bash language, or something else? </i></summary>

Answer: <code>cd</code> is a bash command. However, many other commands such as listing directory contents (<code>ls</code>), copying files and directories (<code>cp</code>), deleting files and directories (<code>rm</code>) etc. are not bash commands but programs. When you type a command into the shell, it will look for a matching program in an ordered list of directories. This list of directories is given by an environment variable called <code>PATH</code>. You can see this environment variable by entering <code>echo $PATH</code> in your terminal. (<code>echo</code> is bash's version of Python's <code>print</code>.)

It is also possible to change directories from inside of Python using `os.chdir`, however, it is much less convenient.  Therefore, it is better to be aware of the directory in which `jupyter lab` is being executed, so that the notebooks and other files you expect to be there are present.  
<br>

</details><br>

The notebook is a system where you can enter lines or blocks of code into "cells", and cells can be executed one at a time.
The results of executing cells are stored in memory,
so the results of each cell executation depends on the cells that have been executed before.
This is a more convenient way of running Python interactively compared to using the console, for many reasons (for example, the console doesn't give you an easy way to save codes).

*Note:* Another principal way of writing Python codes is to store them in text files. 
These text files are called "scripts" if intended to be run directly, or "modules" if intended to be imported.
We won't be writing many scripts in this course, but you're welcome to explore programming this way; in fact the only way to share your codes with the community is by organizing your modules into packages.
When you use any Python module using the `import` statement, the underlying codes are all contained in modules that were installed by `conda` and live somewhere in the `miniconda3` directory tree.
While scripts and modules contain only Python codes, notebooks also contain stored results and other metadata, so the Python interpreter cannot directly read notebooks.
So don't try running a saved notebook as `python my_notebook.ipynb` or you will encounter all sorts of error messages.

## Hello world: Print function, strings vs. variables

A classic (though possibly outdated) tradition is to have your first program print the string `"Hello world!"`
In your Jupyter notebook, enter the following code into a cell, then execute it to view the output.

```python
print("Hello world!")
```

Syntax in Python is very important, just like any programming language. 
Here we are calling the `print` function, and inside the parentheses are the *argument(s)* or input(s) to the function. 
Also notice the quotes around `"Hello world!"`, creating a string.
If the parentheses or the string hadn't been there, you would have gotten error messages, for example:

```python
>>> print "Hello world!"
  File "<stdin>", line 1
    print "Hello world!"
          ^
SyntaxError: Missing parentheses in call to 'print'. Did you mean print("Hello world!")?
```
This error message is actually pretty helpful, in part because it's a very common error; in fact, this was how the `print` statement worked in Python 2, but in Python 3 this has been replaced with the `print()` function.

A different error message is given if the quotes are omitted:

```python
>>> print(Hello)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'Hello' is not defined

>>> print(Hello!)
  File "<stdin>", line 1
    print(Hello!)
               ^
SyntaxError: invalid syntax

>>> print(Hello world!)
  File "<stdin>", line 1
    print(Hello world!)
                ^
SyntaxError: invalid syntax
```

Without quotes, `Hello` and `world` are implied to be variables, but because the variable `Hello` has not been defined, attempting to print it produces an error. 
Additionally, adding an exclamation mark after a variable has no meaning in Python, and neither does two variable names separated by a space.
You'll also notice that the error types are different, where `NameError` indicates the syntax is correct, but the variable isn't defined, whereas `SyntaxError` is printed when the code itself cannot be understood by the interpreter.

Even if this was overly simplistic, the take-home messages are:

- `print()` is a function.
- When calling a function, provide the arguments in parentheses.
- `"Hello world!"` is a string.
- `Hello` is a variable, but currently not defined.
- `Hello world` or `Hello world!` are not correct syntax.

## Assigning variables

There are many useful variable types in Python, such as `string`, `int` (integers), `float` (floating point numbers, the closest thing most programming languages have to true real numbers), `list`, `tuple` (read-only lists), `dictionary`, and `numpy.array`.  Even though `numpy` is not part of the Python standard library, it is almost universally installed into a researcher's environment.

A `bool` is a special kind of number that can only take on two values: `True` (1) or `False` (0).
All Python variables are also *objects*, which you will learn about later.
To assign (i.e. define) a variable, we enter something like this:
```
a = 3.0
```
where `a` is the variable name and `3.0` is the value.
(`3.0` is an example of a *literal*, or a fixed value that is literally typed out.)
When assigning a variable, Python will automatically assign the variable type, which is different from many other programming languages like C or Fortran that require you to specify the type.

In certain cases it will be helpful to change the type of a variable. 
There are special functions for this; for example, `a = 3; b = float(a)` will set `b` to a float with a value of `3.0`.
You might have noticed that we actually created a new variable with the new type; we did not change the type of `a` in-place.

## Operations

There are various ways to work with variables.
From a beginner's perspective, one of the easiest ways is to use standard math operations `+, -, *, /` (add, subtract, multiply, divide).
In the expression `c = a + b`, `a` and `b` are called operands and `+` is called the operator; the result is assigned to `c`.

The result of these operations on numbers seems obvious from basic math, but it goes deeper than that.
A math equation is a statement that the left and right side are equal, and the equation is unchanged if the left and right side are swapped.
In Python programming, the line `c = a + b` *assigns* the value of `c` based on the result of the right hand side, even if `c` was previously undefined, and `a + b = c` has no meaning.
What's more, the behavior of each operation depends on the variable types of the operands.
For example, adding or multiplying two ints results in an int, but adding or multiplying an int and a float results in a float.
The division of two ints also results in a float.
Things worked differently in Python 2, where the result of dividing two integers was another integer equal to the result of floating point division rounded down (in Python 3, that result is obtained using the `//` operator).

Two strings can be added resulting in a third string consisting of the two joined together.
Adding two lists also gives the same behavior, and that may be consistent with your intuition.
However, subtraction is not defined for two strings or two lists, and addition is not defined between a string and a list either.
A NumPy array defined using `myArr = numpy.array([1, 2, 3])` might resemble a list defined as `myList = [1, 2, 3]`, but the multiplication operations are defined differently.
Multiplying a NumPy array by an int or float results in each element being multiplied, whereas multiplication of a list by an int results in replicating the list multiple times (there is no definition of multiplying a list by a float).
The take-home message is that operations are more varied and complex than the corresponding basic math operations, and the result depends on the variable types of the operands (i.e. the variables being operated on).
While Python is often advertised as being an "intuitive" language, it actually depends on how well your own intuition lines up with the programmers that designed the language.

There are many other operations and I can't give a complete list. For example, "modulo" `a \% b` means "the remainder of integer division of `a` by `b`".
The power operation, i.e. "`a` raised to the power of `b`", uses a double star: `a ** b`.
The operation `>` stands for "greater than", and it returns True or False.
There are also `>=, <, <=, ==` operations; `==` deserves special mention because it is used to check if two variables are equal.
All of these comparison operations return True or False, so they are very different from the assignment operation `=`.

There are other assignment operations as well. For example, `a += b` assigns a new value of `a` by adding the value of `b` to the original value.  Other assignment operators include `-=, *=, /=`, which results in subtracting, multiplying, or dividing the LHS by the RHS, respectively.

```python
# Some examples of operations on different variable types.
>>> 3*5
15 # Int
>>> 3*5.0
15.0 # Float
>>> 3/5
0.6 # Float
>>> "a" + "b"
'ab' # String
>>> [1, 2, 3] + ['4', 5.0, 6]
[1, 2, 3, '4', 5.0, 6] # Addition of lists
>>> "ab" - "a"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for -: 'str' and 'str'
```

## Functions
Functions, which have inputs (*arguments*) and outputs (*return values*), can perform more complex tasks than operations.
For example, there is no operation for the factorial: entering `10!` will return a syntax error.
Fortunately, the factorial function has been defined in the SciPy package under the `scipy.special` module, so we can import and use it as follows:
```
[1] >>> from scipy import special
[2] >>> special.factorial(10)
3628800.0
[3] >>> scipy.special.factorial(10.5)
11899423.08396225
[4] >>> scipy.special.factorial(11)
39916800.0
[5] >>> scipy.special.factorial(100)
9.332621544394415e+157
[6] >>> scipy.special.factorial(1000)
inf
[7] >>> scipy.special.factorial(100) - scipy.special.factorial(100) + 1
1.0
[8] >>> scipy.special.factorial(100) - (scipy.special.factorial(100) - 1)
0.0
```
There's a few things to learn here. Note that the return type of `scipy.special.factorial()` is a float. 
You might also be surprised to find that the function gives a return value for 10.5, and that's because the function actually has methods to calculate the "gamma function", a continuous function whose values for integer arguments are given by \\( \Gamma(n) = (n-1)! \\) .
For an input value of 1000, the result is too large for the float variable type, so `inf` is returned instead.

Also, notice the weird behavior of lines [7] and [8]: mathematically we know that \\( 100! - 100! + 1 = 1\\) and it shouldn't matter how we group the operations, but in Python the result is either 1.0 or 0.0 depending on the order of operations.
In line [7], the expression is evaluated from left to right, so the result of `scipy.special.factorial(100) - scipy.special.factorial(100)` results in 0, followed by adding 1.
In line [8], the parentheses forces `(scipy.special.factorial(100) - 1)` to be evaluated first, but due to the finite precision of floating point numbers (Python floats have 64 bits, corresponding to about 16 significant figures), subtracting 1 from `9.332621544394415e+157` does not change the result at all.
Although these issues do not always come up in practice, they can seriously throw you off when they do, so it is always a good idea to keep the finite precision of floating point numbers in mind.

When you're not sure how to use a function in terms of its arguments and/or return values, you can check the function's documentation. 
You can easily do this in the Jupyter notebook by passing the function name into `help()` or by appending a question mark:

![documentation]({{ site.baseurl }}/assets/images/week1/documentation.png){: width="650"}

As you can see from the screenshot, the documentation tells you a great deal about the different ways the function can be called; one important detail is that it also accepts array inputs, which is very common in NumPy and SciPy.
Although the documentation does not directly affect how the code runs, it can be just as important for the user as the code itself, so make sure you also write quality documentation!
*Note:* Adding a `#` in Python makes everything on the line following it into a comment.  Enclosing text between a pair of triple quotes `"""` creates a *docstring*, which is also how functions are documented.



## Further Reading
- [Intro to Scientific Programming with Python - open access (also on Canvas)](https://library.oapen.org/bitstream/id/56d27e73-e92a-4398-8198-239be7aacc93/2020_Book_IntroductionToScientificProgra.pdf)

## Notebooks
